(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[1],{

/***/ "./node_modules/color-harmony/lib/color-harmony.js":
/*!*********************************************************!*\
  !*** ./node_modules/color-harmony/lib/color-harmony.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * color-harmony\n * https://github.com/skratchdot/color-harmony\n *\n * Copyright (c) 2014 skratchdot\n * Licensed under the MIT license.\n */\n\n\n\nvar onecolor = __webpack_require__(/*! onecolor */ \"./node_modules/onecolor/one-color-all-debug.js\");\n\nvar Harmonizer = function () {\n\tvar api = this;\n\n\t/* degree arrays taken from: https://github.com/brehaut/color-js/ */\n\tvar harmonies = {\n\t\tcomplementary: [0,180],\n\t\tsplitComplementary: [0,150,320],\n\t\tsplitComplementaryCW: [0,150,300],\n\t\tsplitComplementaryCCW: [0,60,210],\n\t\ttriadic: [0,120,240],\n\t\tclash: [0,90,270],\n\t\ttetradic: [0,90,180,270],\n\t\tfourToneCW: [0,60,180,240],\n\t\tfourToneCCW: [0,120,180,300],\n\t\tfiveToneA: [0,115,155,205,245],\n\t\tfiveToneB: [0,40,90,130,245],\n\t\tfiveToneC: [0,50,90,205,320],\n\t\tfiveToneD: [0,40,155,270,310],\n\t\tfiveToneE: [0,115,230,270,320],\n\t\tsixToneCW: [0,30,120,150,240,270],\n\t\tsixToneCCW: [0,90,120,210,240,330],\n\t\tneutral: [0,15,30,45,60,75],\n\t\tanalogous: [0,30,60,90,120,150]\n\t};\n\n\tvar parseColor = function (colorString) {\n\t\tvar color = onecolor(colorString);\n\t\tif (!color) {\n\t\t\tcolor = onecolor('#000000');\n\t\t}\n\t\treturn color;\n\t};\n\t\n\tvar harmonize = function (color, degrees) {\n\t\tvar ret = [], hsl, h, s, l, a, i, degree;\n\t\thsl = color.hsl();\n\t\th = hsl._hue;\n\t\ts = hsl._saturation;\n\t\tl = hsl._lightness;\n\t\ta = hsl._alpha;\n\t\tfor (i = 0; i < degrees.length; i++) {\n\t\t\tdegree = degrees[i];\n\t\t\tif (isFinite(degree) && typeof degree === 'number') {\n\t\t\t\tret.push(new onecolor.HSL((h + (1 / 360 * degree)) % 1, s, l, a).hex());\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tvar scaleTo = function (color, size, scale) {\n\t\tvar i, ret = [], r, g, b, a, scaleR, scaleG, scaleB;\n\t\tif (!isFinite(size) || typeof size !== 'number') {\n\t\t\tsize = 10;\n\t\t}\n\t\tr = color.red();\n\t\tg = color.green();\n\t\tb = color.blue();\n\t\ta = color.alpha();\n\t\tscaleR = (scale - r) / size;\n\t\tscaleG = (scale - g) / size;\n\t\tscaleB = (scale - b) / size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tret.push(new onecolor.RGB(r, g, b, a).hex());\n\t\t\tr += scaleR;\n\t\t\tg += scaleG;\n\t\t\tb += scaleB;\n\t\t}\n\t\treturn ret;\n\t};\n\n\tapi.add = function (harmonyName, degreeArray) {\n\t\tif (Array.isArray(degreeArray)) {\n\t\t\tharmonies[harmonyName] = degreeArray;\n\t\t}\n\t};\n\n\tapi.harmonizeAll = function (colorString) {\n\t\tvar ret = {};\n\t\tvar color = parseColor(colorString);\n\t\tfor (var harmonyName in harmonies) {\n\t\t\tif (harmonies.hasOwnProperty(harmonyName)) {\n\t\t\t\tret[harmonyName] = harmonize(color, harmonies[harmonyName]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\n\tapi.harmonize = function (colorString, harmony) {\n\t\tvar color = parseColor(colorString);\n\t\tif (harmonies.hasOwnProperty(harmony)) {\n\t\t\tharmony = harmonies[harmony];\n\t\t}\n\t\tif (Array.isArray(harmony)) {\n\t\t\treturn harmonize(color, harmony);\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t};\n\n\t// mix with black (#000000)\n\tapi.shades = function (colorString, size) {\n\t\treturn scaleTo(parseColor(colorString), size, 0);\n\t};\n\n\t// mix with white (#ffffff)\n\tapi.tints = function (colorString, size) {\n\t\treturn scaleTo(parseColor(colorString), size, 1);\n\t};\n\n\t// mix with middle gray (#777777)\n\tapi.tones = function (colorString, size) {\n\t\treturn scaleTo(parseColor(colorString), size, 0.5);\n\t};\n\n\treturn api;\n};\n\nexports.Harmonizer = function () {\n\treturn new Harmonizer();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbG9yLWhhcm1vbnkvbGliL2NvbG9yLWhhcm1vbnkuanM/Y2NkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsZ0VBQVU7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvbG9yLWhhcm1vbnkvbGliL2NvbG9yLWhhcm1vbnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogY29sb3ItaGFybW9ueVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NrcmF0Y2hkb3QvY29sb3ItaGFybW9ueVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBza3JhdGNoZG90XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgb25lY29sb3IgPSByZXF1aXJlKCdvbmVjb2xvcicpO1xuXG52YXIgSGFybW9uaXplciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0LyogZGVncmVlIGFycmF5cyB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vYnJlaGF1dC9jb2xvci1qcy8gKi9cblx0dmFyIGhhcm1vbmllcyA9IHtcblx0XHRjb21wbGVtZW50YXJ5OiBbMCwxODBdLFxuXHRcdHNwbGl0Q29tcGxlbWVudGFyeTogWzAsMTUwLDMyMF0sXG5cdFx0c3BsaXRDb21wbGVtZW50YXJ5Q1c6IFswLDE1MCwzMDBdLFxuXHRcdHNwbGl0Q29tcGxlbWVudGFyeUNDVzogWzAsNjAsMjEwXSxcblx0XHR0cmlhZGljOiBbMCwxMjAsMjQwXSxcblx0XHRjbGFzaDogWzAsOTAsMjcwXSxcblx0XHR0ZXRyYWRpYzogWzAsOTAsMTgwLDI3MF0sXG5cdFx0Zm91clRvbmVDVzogWzAsNjAsMTgwLDI0MF0sXG5cdFx0Zm91clRvbmVDQ1c6IFswLDEyMCwxODAsMzAwXSxcblx0XHRmaXZlVG9uZUE6IFswLDExNSwxNTUsMjA1LDI0NV0sXG5cdFx0Zml2ZVRvbmVCOiBbMCw0MCw5MCwxMzAsMjQ1XSxcblx0XHRmaXZlVG9uZUM6IFswLDUwLDkwLDIwNSwzMjBdLFxuXHRcdGZpdmVUb25lRDogWzAsNDAsMTU1LDI3MCwzMTBdLFxuXHRcdGZpdmVUb25lRTogWzAsMTE1LDIzMCwyNzAsMzIwXSxcblx0XHRzaXhUb25lQ1c6IFswLDMwLDEyMCwxNTAsMjQwLDI3MF0sXG5cdFx0c2l4VG9uZUNDVzogWzAsOTAsMTIwLDIxMCwyNDAsMzMwXSxcblx0XHRuZXV0cmFsOiBbMCwxNSwzMCw0NSw2MCw3NV0sXG5cdFx0YW5hbG9nb3VzOiBbMCwzMCw2MCw5MCwxMjAsMTUwXVxuXHR9O1xuXG5cdHZhciBwYXJzZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yU3RyaW5nKSB7XG5cdFx0dmFyIGNvbG9yID0gb25lY29sb3IoY29sb3JTdHJpbmcpO1xuXHRcdGlmICghY29sb3IpIHtcblx0XHRcdGNvbG9yID0gb25lY29sb3IoJyMwMDAwMDAnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbG9yO1xuXHR9O1xuXHRcblx0dmFyIGhhcm1vbml6ZSA9IGZ1bmN0aW9uIChjb2xvciwgZGVncmVlcykge1xuXHRcdHZhciByZXQgPSBbXSwgaHNsLCBoLCBzLCBsLCBhLCBpLCBkZWdyZWU7XG5cdFx0aHNsID0gY29sb3IuaHNsKCk7XG5cdFx0aCA9IGhzbC5faHVlO1xuXHRcdHMgPSBoc2wuX3NhdHVyYXRpb247XG5cdFx0bCA9IGhzbC5fbGlnaHRuZXNzO1xuXHRcdGEgPSBoc2wuX2FscGhhO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkZWdyZWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkZWdyZWUgPSBkZWdyZWVzW2ldO1xuXHRcdFx0aWYgKGlzRmluaXRlKGRlZ3JlZSkgJiYgdHlwZW9mIGRlZ3JlZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmV0LnB1c2gobmV3IG9uZWNvbG9yLkhTTCgoaCArICgxIC8gMzYwICogZGVncmVlKSkgJSAxLCBzLCBsLCBhKS5oZXgoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0dmFyIHNjYWxlVG8gPSBmdW5jdGlvbiAoY29sb3IsIHNpemUsIHNjYWxlKSB7XG5cdFx0dmFyIGksIHJldCA9IFtdLCByLCBnLCBiLCBhLCBzY2FsZVIsIHNjYWxlRywgc2NhbGVCO1xuXHRcdGlmICghaXNGaW5pdGUoc2l6ZSkgfHwgdHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRzaXplID0gMTA7XG5cdFx0fVxuXHRcdHIgPSBjb2xvci5yZWQoKTtcblx0XHRnID0gY29sb3IuZ3JlZW4oKTtcblx0XHRiID0gY29sb3IuYmx1ZSgpO1xuXHRcdGEgPSBjb2xvci5hbHBoYSgpO1xuXHRcdHNjYWxlUiA9IChzY2FsZSAtIHIpIC8gc2l6ZTtcblx0XHRzY2FsZUcgPSAoc2NhbGUgLSBnKSAvIHNpemU7XG5cdFx0c2NhbGVCID0gKHNjYWxlIC0gYikgLyBzaXplO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcblx0XHRcdHJldC5wdXNoKG5ldyBvbmVjb2xvci5SR0IociwgZywgYiwgYSkuaGV4KCkpO1xuXHRcdFx0ciArPSBzY2FsZVI7XG5cdFx0XHRnICs9IHNjYWxlRztcblx0XHRcdGIgKz0gc2NhbGVCO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdGFwaS5hZGQgPSBmdW5jdGlvbiAoaGFybW9ueU5hbWUsIGRlZ3JlZUFycmF5KSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGVncmVlQXJyYXkpKSB7XG5cdFx0XHRoYXJtb25pZXNbaGFybW9ueU5hbWVdID0gZGVncmVlQXJyYXk7XG5cdFx0fVxuXHR9O1xuXG5cdGFwaS5oYXJtb25pemVBbGwgPSBmdW5jdGlvbiAoY29sb3JTdHJpbmcpIHtcblx0XHR2YXIgcmV0ID0ge307XG5cdFx0dmFyIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvclN0cmluZyk7XG5cdFx0Zm9yICh2YXIgaGFybW9ueU5hbWUgaW4gaGFybW9uaWVzKSB7XG5cdFx0XHRpZiAoaGFybW9uaWVzLmhhc093blByb3BlcnR5KGhhcm1vbnlOYW1lKSkge1xuXHRcdFx0XHRyZXRbaGFybW9ueU5hbWVdID0gaGFybW9uaXplKGNvbG9yLCBoYXJtb25pZXNbaGFybW9ueU5hbWVdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXHRhcGkuaGFybW9uaXplID0gZnVuY3Rpb24gKGNvbG9yU3RyaW5nLCBoYXJtb255KSB7XG5cdFx0dmFyIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvclN0cmluZyk7XG5cdFx0aWYgKGhhcm1vbmllcy5oYXNPd25Qcm9wZXJ0eShoYXJtb255KSkge1xuXHRcdFx0aGFybW9ueSA9IGhhcm1vbmllc1toYXJtb255XTtcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoaGFybW9ueSkpIHtcblx0XHRcdHJldHVybiBoYXJtb25pemUoY29sb3IsIGhhcm1vbnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9O1xuXG5cdC8vIG1peCB3aXRoIGJsYWNrICgjMDAwMDAwKVxuXHRhcGkuc2hhZGVzID0gZnVuY3Rpb24gKGNvbG9yU3RyaW5nLCBzaXplKSB7XG5cdFx0cmV0dXJuIHNjYWxlVG8ocGFyc2VDb2xvcihjb2xvclN0cmluZyksIHNpemUsIDApO1xuXHR9O1xuXG5cdC8vIG1peCB3aXRoIHdoaXRlICgjZmZmZmZmKVxuXHRhcGkudGludHMgPSBmdW5jdGlvbiAoY29sb3JTdHJpbmcsIHNpemUpIHtcblx0XHRyZXR1cm4gc2NhbGVUbyhwYXJzZUNvbG9yKGNvbG9yU3RyaW5nKSwgc2l6ZSwgMSk7XG5cdH07XG5cblx0Ly8gbWl4IHdpdGggbWlkZGxlIGdyYXkgKCM3Nzc3NzcpXG5cdGFwaS50b25lcyA9IGZ1bmN0aW9uIChjb2xvclN0cmluZywgc2l6ZSkge1xuXHRcdHJldHVybiBzY2FsZVRvKHBhcnNlQ29sb3IoY29sb3JTdHJpbmcpLCBzaXplLCAwLjUpO1xuXHR9O1xuXG5cdHJldHVybiBhcGk7XG59O1xuXG5leHBvcnRzLkhhcm1vbml6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgSGFybW9uaXplcigpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/color-harmony/lib/color-harmony.js\n");

/***/ }),

/***/ "./node_modules/onecolor/one-color-all-debug.js":
/*!******************************************************!*\
  !*** ./node_modules/onecolor/one-color-all-debug.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*jshint evil:true, onevar:false*/\n/*global define*/\nvar installedColorSpaces = [],\n    namedColors = {},\n    undef = function (obj) {\n        return typeof obj === 'undefined';\n    },\n    channelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)(%)?\\s*/,\n    percentageChannelRegExp = /\\s*(\\.\\d+|100|\\d?\\d(?:\\.\\d+)?)%\\s*/,\n    alphaChannelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)\\s*/,\n    cssColorRegExp = new RegExp(\n                         \"^(rgb|hsl|hsv)a?\" +\n                         \"\\\\(\" +\n                             channelRegExp.source + \",\" +\n                             channelRegExp.source + \",\" +\n                             channelRegExp.source +\n                             \"(?:,\" + alphaChannelRegExp.source + \")?\" +\n                         \"\\\\)$\", \"i\");\n\nfunction ONECOLOR(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n        if (typeof obj[0] === 'string' && typeof ONECOLOR[obj[0]] === 'function') {\n            // Assumed array from .toJSON()\n            return new ONECOLOR[obj[0]](obj.slice(1, obj.length));\n        } else if (obj.length === 4) {\n            // Assumed 4 element int RGB array from canvas with all channels [0;255]\n            return new ONECOLOR.RGB(obj[0] / 255, obj[1] / 255, obj[2] / 255, obj[3] / 255);\n        }\n    } else if (typeof obj === 'string') {\n        var lowerCased = obj.toLowerCase();\n        if (namedColors[lowerCased]) {\n            obj = '#' + namedColors[lowerCased];\n        }\n        if (lowerCased === 'transparent') {\n            obj = 'rgba(0,0,0,0)';\n        }\n        // Test for CSS rgb(....) string\n        var matchCssSyntax = obj.match(cssColorRegExp);\n        if (matchCssSyntax) {\n            var colorSpaceName = matchCssSyntax[1].toUpperCase(),\n                alpha = undef(matchCssSyntax[8]) ? matchCssSyntax[8] : parseFloat(matchCssSyntax[8]),\n                hasHue = colorSpaceName[0] === 'H',\n                firstChannelDivisor = matchCssSyntax[3] ? 100 : (hasHue ? 360 : 255),\n                secondChannelDivisor = (matchCssSyntax[5] || hasHue) ? 100 : 255,\n                thirdChannelDivisor = (matchCssSyntax[7] || hasHue) ? 100 : 255;\n            if (undef(ONECOLOR[colorSpaceName])) {\n                throw new Error(\"one.color.\" + colorSpaceName + \" is not installed.\");\n            }\n            return new ONECOLOR[colorSpaceName](\n                parseFloat(matchCssSyntax[2]) / firstChannelDivisor,\n                parseFloat(matchCssSyntax[4]) / secondChannelDivisor,\n                parseFloat(matchCssSyntax[6]) / thirdChannelDivisor,\n                alpha\n            );\n        }\n        // Assume hex syntax\n        if (obj.length < 6) {\n            // Allow CSS shorthand\n            obj = obj.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '$1$1$2$2$3$3');\n        }\n        // Split obj into red, green, and blue components\n        var hexMatch = obj.match(/^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i);\n        if (hexMatch) {\n            return new ONECOLOR.RGB(\n                parseInt(hexMatch[1], 16) / 255,\n                parseInt(hexMatch[2], 16) / 255,\n                parseInt(hexMatch[3], 16) / 255\n            );\n        }\n\n        // No match so far. Lets try the less likely ones\n        if (ONECOLOR.CMYK) {\n            var cmykMatch = obj.match(new RegExp(\n                             \"^cmyk\" +\n                             \"\\\\(\" +\n                                 percentageChannelRegExp.source + \",\" +\n                                 percentageChannelRegExp.source + \",\" +\n                                 percentageChannelRegExp.source + \",\" +\n                                 percentageChannelRegExp.source +\n                             \"\\\\)$\", \"i\"));\n            if (cmykMatch) {\n                return new ONECOLOR.CMYK(\n                    parseFloat(cmykMatch[1]) / 100,\n                    parseFloat(cmykMatch[2]) / 100,\n                    parseFloat(cmykMatch[3]) / 100,\n                    parseFloat(cmykMatch[4]) / 100\n                );\n            }\n        }\n    } else if (typeof obj === 'object' && obj.isColor) {\n        return obj;\n    }\n    return false;\n}\n\nfunction installColorSpace(colorSpaceName, propertyNames, config) {\n    ONECOLOR[colorSpaceName] = new Function(propertyNames.join(\",\"),\n        // Allow passing an array to the constructor:\n        \"if (Object.prototype.toString.apply(\" + propertyNames[0] + \") === '[object Array]') {\" +\n            propertyNames.map(function (propertyName, i) {\n                return propertyName + \"=\" + propertyNames[0] + \"[\" + i + \"];\";\n            }).reverse().join(\"\") +\n        \"}\" +\n        \"if (\" + propertyNames.filter(function (propertyName) {\n            return propertyName !== 'alpha';\n        }).map(function (propertyName) {\n            return \"isNaN(\" + propertyName + \")\";\n        }).join(\"||\") + \"){\" + \"throw new Error(\\\"[\" + colorSpaceName + \"]: Invalid color: (\\\"+\" + propertyNames.join(\"+\\\",\\\"+\") + \"+\\\")\\\");}\" +\n        propertyNames.map(function (propertyName) {\n            if (propertyName === 'hue') {\n                return \"this._hue=hue<0?hue-Math.floor(hue):hue%1\"; // Wrap\n            } else if (propertyName === 'alpha') {\n                return \"this._alpha=(isNaN(alpha)||alpha>1)?1:(alpha<0?0:alpha);\";\n            } else {\n                return \"this._\" + propertyName + \"=\" + propertyName + \"<0?0:(\" + propertyName + \">1?1:\" + propertyName + \")\";\n            }\n        }).join(\";\") + \";\"\n    );\n    ONECOLOR[colorSpaceName].propertyNames = propertyNames;\n\n    var prototype = ONECOLOR[colorSpaceName].prototype;\n\n    ['valueOf', 'hex', 'hexa', 'css', 'cssa'].forEach(function (methodName) {\n        prototype[methodName] = prototype[methodName] || (colorSpaceName === 'RGB' ? prototype.hex : new Function(\"return this.rgb().\" + methodName + \"();\"));\n    });\n\n    prototype.isColor = true;\n\n    prototype.equals = function (otherColor, epsilon) {\n        if (undef(epsilon)) {\n            epsilon = 1e-10;\n        }\n\n        otherColor = otherColor[colorSpaceName.toLowerCase()]();\n\n        for (var i = 0; i < propertyNames.length; i = i + 1) {\n            if (Math.abs(this['_' + propertyNames[i]] - otherColor['_' + propertyNames[i]]) > epsilon) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    prototype.toJSON = new Function(\n        \"return ['\" + colorSpaceName + \"', \" +\n            propertyNames.map(function (propertyName) {\n                return \"this._\" + propertyName;\n            }, this).join(\", \") +\n        \"];\"\n    );\n\n    for (var propertyName in config) {\n        if (config.hasOwnProperty(propertyName)) {\n            var matchFromColorSpace = propertyName.match(/^from(.*)$/);\n            if (matchFromColorSpace) {\n                ONECOLOR[matchFromColorSpace[1].toUpperCase()].prototype[colorSpaceName.toLowerCase()] = config[propertyName];\n            } else {\n                prototype[propertyName] = config[propertyName];\n            }\n        }\n    }\n\n    // It is pretty easy to implement the conversion to the same color space:\n    prototype[colorSpaceName.toLowerCase()] = function () {\n        return this;\n    };\n    prototype.toString = new Function(\"return \\\"[one.color.\" + colorSpaceName + \":\\\"+\" + propertyNames.map(function (propertyName, i) {\n        return \"\\\" \" + propertyNames[i] + \"=\\\"+this._\" + propertyName;\n    }).join(\"+\") + \"+\\\"]\\\";\");\n\n    // Generate getters and setters\n    propertyNames.forEach(function (propertyName, i) {\n        prototype[propertyName] = prototype[propertyName === 'black' ? 'k' : propertyName[0]] = new Function(\"value\", \"isDelta\",\n            // Simple getter mode: color.red()\n            \"if (typeof value === 'undefined') {\" +\n                \"return this._\" + propertyName + \";\" +\n            \"}\" +\n            // Adjuster: color.red(+.2, true)\n            \"if (isDelta) {\" +\n                \"return new this.constructor(\" + propertyNames.map(function (otherPropertyName, i) {\n                    return \"this._\" + otherPropertyName + (propertyName === otherPropertyName ? \"+value\" : \"\");\n                }).join(\", \") + \");\" +\n            \"}\" +\n            // Setter: color.red(.2);\n            \"return new this.constructor(\" + propertyNames.map(function (otherPropertyName, i) {\n                return propertyName === otherPropertyName ? \"value\" : \"this._\" + otherPropertyName;\n            }).join(\", \") + \");\");\n    });\n\n    function installForeignMethods(targetColorSpaceName, sourceColorSpaceName) {\n        var obj = {};\n        obj[sourceColorSpaceName.toLowerCase()] = new Function(\"return this.rgb().\" + sourceColorSpaceName.toLowerCase() + \"();\"); // Fallback\n        ONECOLOR[sourceColorSpaceName].propertyNames.forEach(function (propertyName, i) {\n            obj[propertyName] = obj[propertyName === 'black' ? 'k' : propertyName[0]] = new Function(\"value\", \"isDelta\", \"return this.\" + sourceColorSpaceName.toLowerCase() + \"().\" + propertyName + \"(value, isDelta);\");\n        });\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop) && ONECOLOR[targetColorSpaceName].prototype[prop] === undefined) {\n                ONECOLOR[targetColorSpaceName].prototype[prop] = obj[prop];\n            }\n        }\n    }\n\n    installedColorSpaces.forEach(function (otherColorSpaceName) {\n        installForeignMethods(colorSpaceName, otherColorSpaceName);\n        installForeignMethods(otherColorSpaceName, colorSpaceName);\n    });\n\n    installedColorSpaces.push(colorSpaceName);\n}\n\nONECOLOR.installMethod = function (name, fn) {\n    installedColorSpaces.forEach(function (colorSpace) {\n        ONECOLOR[colorSpace].prototype[name] = fn;\n    });\n};\n\ninstallColorSpace('RGB', ['red', 'green', 'blue', 'alpha'], {\n    hex: function () {\n        var hexString = (Math.round(255 * this._red) * 0x10000 + Math.round(255 * this._green) * 0x100 + Math.round(255 * this._blue)).toString(16);\n        return '#' + ('00000'.substr(0, 6 - hexString.length)) + hexString;\n    },\n\n    hexa: function () {\n        var alphaString = Math.round(this._alpha * 255).toString(16);\n        return '#' + '00'.substr(0, 2 - alphaString.length) + alphaString + this.hex().substr(1, 6);\n    },\n\n    css: function () {\n        return \"rgb(\" + Math.round(255 * this._red) + \",\" + Math.round(255 * this._green) + \",\" + Math.round(255 * this._blue) + \")\";\n    },\n\n    cssa: function () {\n        return \"rgba(\" + Math.round(255 * this._red) + \",\" + Math.round(255 * this._green) + \",\" + Math.round(255 * this._blue) + \",\" + this._alpha + \")\";\n    }\n});\nif ( true && !undef(__webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\"))) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return ONECOLOR;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else if (true) {\n    // Node module export\n    module.exports = ONECOLOR;\n} else {}\n\nif (typeof jQuery !== 'undefined' && undef(jQuery.color)) {\n    jQuery.color = ONECOLOR;\n}\n\n/*global namedColors*/\nnamedColors = {\n    aliceblue: 'f0f8ff',\n    antiquewhite: 'faebd7',\n    aqua: '0ff',\n    aquamarine: '7fffd4',\n    azure: 'f0ffff',\n    beige: 'f5f5dc',\n    bisque: 'ffe4c4',\n    black: '000',\n    blanchedalmond: 'ffebcd',\n    blue: '00f',\n    blueviolet: '8a2be2',\n    brown: 'a52a2a',\n    burlywood: 'deb887',\n    cadetblue: '5f9ea0',\n    chartreuse: '7fff00',\n    chocolate: 'd2691e',\n    coral: 'ff7f50',\n    cornflowerblue: '6495ed',\n    cornsilk: 'fff8dc',\n    crimson: 'dc143c',\n    cyan: '0ff',\n    darkblue: '00008b',\n    darkcyan: '008b8b',\n    darkgoldenrod: 'b8860b',\n    darkgray: 'a9a9a9',\n    darkgrey: 'a9a9a9',\n    darkgreen: '006400',\n    darkkhaki: 'bdb76b',\n    darkmagenta: '8b008b',\n    darkolivegreen: '556b2f',\n    darkorange: 'ff8c00',\n    darkorchid: '9932cc',\n    darkred: '8b0000',\n    darksalmon: 'e9967a',\n    darkseagreen: '8fbc8f',\n    darkslateblue: '483d8b',\n    darkslategray: '2f4f4f',\n    darkslategrey: '2f4f4f',\n    darkturquoise: '00ced1',\n    darkviolet: '9400d3',\n    deeppink: 'ff1493',\n    deepskyblue: '00bfff',\n    dimgray: '696969',\n    dimgrey: '696969',\n    dodgerblue: '1e90ff',\n    firebrick: 'b22222',\n    floralwhite: 'fffaf0',\n    forestgreen: '228b22',\n    fuchsia: 'f0f',\n    gainsboro: 'dcdcdc',\n    ghostwhite: 'f8f8ff',\n    gold: 'ffd700',\n    goldenrod: 'daa520',\n    gray: '808080',\n    grey: '808080',\n    green: '008000',\n    greenyellow: 'adff2f',\n    honeydew: 'f0fff0',\n    hotpink: 'ff69b4',\n    indianred: 'cd5c5c',\n    indigo: '4b0082',\n    ivory: 'fffff0',\n    khaki: 'f0e68c',\n    lavender: 'e6e6fa',\n    lavenderblush: 'fff0f5',\n    lawngreen: '7cfc00',\n    lemonchiffon: 'fffacd',\n    lightblue: 'add8e6',\n    lightcoral: 'f08080',\n    lightcyan: 'e0ffff',\n    lightgoldenrodyellow: 'fafad2',\n    lightgray: 'd3d3d3',\n    lightgrey: 'd3d3d3',\n    lightgreen: '90ee90',\n    lightpink: 'ffb6c1',\n    lightsalmon: 'ffa07a',\n    lightseagreen: '20b2aa',\n    lightskyblue: '87cefa',\n    lightslategray: '789',\n    lightslategrey: '789',\n    lightsteelblue: 'b0c4de',\n    lightyellow: 'ffffe0',\n    lime: '0f0',\n    limegreen: '32cd32',\n    linen: 'faf0e6',\n    magenta: 'f0f',\n    maroon: '800000',\n    mediumaquamarine: '66cdaa',\n    mediumblue: '0000cd',\n    mediumorchid: 'ba55d3',\n    mediumpurple: '9370d8',\n    mediumseagreen: '3cb371',\n    mediumslateblue: '7b68ee',\n    mediumspringgreen: '00fa9a',\n    mediumturquoise: '48d1cc',\n    mediumvioletred: 'c71585',\n    midnightblue: '191970',\n    mintcream: 'f5fffa',\n    mistyrose: 'ffe4e1',\n    moccasin: 'ffe4b5',\n    navajowhite: 'ffdead',\n    navy: '000080',\n    oldlace: 'fdf5e6',\n    olive: '808000',\n    olivedrab: '6b8e23',\n    orange: 'ffa500',\n    orangered: 'ff4500',\n    orchid: 'da70d6',\n    palegoldenrod: 'eee8aa',\n    palegreen: '98fb98',\n    paleturquoise: 'afeeee',\n    palevioletred: 'd87093',\n    papayawhip: 'ffefd5',\n    peachpuff: 'ffdab9',\n    peru: 'cd853f',\n    pink: 'ffc0cb',\n    plum: 'dda0dd',\n    powderblue: 'b0e0e6',\n    purple: '800080',\n    rebeccapurple: '639',\n    red: 'f00',\n    rosybrown: 'bc8f8f',\n    royalblue: '4169e1',\n    saddlebrown: '8b4513',\n    salmon: 'fa8072',\n    sandybrown: 'f4a460',\n    seagreen: '2e8b57',\n    seashell: 'fff5ee',\n    sienna: 'a0522d',\n    silver: 'c0c0c0',\n    skyblue: '87ceeb',\n    slateblue: '6a5acd',\n    slategray: '708090',\n    slategrey: '708090',\n    snow: 'fffafa',\n    springgreen: '00ff7f',\n    steelblue: '4682b4',\n    tan: 'd2b48c',\n    teal: '008080',\n    thistle: 'd8bfd8',\n    tomato: 'ff6347',\n    turquoise: '40e0d0',\n    violet: 'ee82ee',\n    wheat: 'f5deb3',\n    white: 'fff',\n    whitesmoke: 'f5f5f5',\n    yellow: 'ff0',\n    yellowgreen: '9acd32'\n};\n\n/*global INCLUDE, installColorSpace, ONECOLOR*/\n\ninstallColorSpace('XYZ', ['x', 'y', 'z', 'alpha'], {\n    fromRgb: function () {\n        // http://www.easyrgb.com/index.php?X=MATH&H=02#text2\n        var convert = function (channel) {\n                return channel > 0.04045 ?\n                    Math.pow((channel + 0.055) / 1.055, 2.4) :\n                    channel / 12.92;\n            },\n            r = convert(this._red),\n            g = convert(this._green),\n            b = convert(this._blue);\n\n        // Reference white point sRGB D65:\n        // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n        return new ONECOLOR.XYZ(\n            r * 0.4124564 + g * 0.3575761 + b * 0.1804375,\n            r * 0.2126729 + g * 0.7151522 + b * 0.0721750,\n            r * 0.0193339 + g * 0.1191920 + b * 0.9503041,\n            this._alpha\n        );\n    },\n\n    rgb: function () {\n        // http://www.easyrgb.com/index.php?X=MATH&H=01#text1\n        var x = this._x,\n            y = this._y,\n            z = this._z,\n            convert = function (channel) {\n                return channel > 0.0031308 ?\n                    1.055 * Math.pow(channel, 1 / 2.4) - 0.055 :\n                    12.92 * channel;\n            };\n\n        // Reference white point sRGB D65:\n        // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n        return new ONECOLOR.RGB(\n            convert(x *  3.2404542 + y * -1.5371385 + z * -0.4985314),\n            convert(x * -0.9692660 + y *  1.8760108 + z *  0.0415560),\n            convert(x *  0.0556434 + y * -0.2040259 + z *  1.0572252),\n            this._alpha\n        );\n    },\n\n    lab: function () {\n        // http://www.easyrgb.com/index.php?X=MATH&H=07#text7\n        var convert = function (channel) {\n                return channel > 0.008856 ?\n                    Math.pow(channel, 1 / 3) :\n                    7.787037 * channel + 4 / 29;\n            },\n            x = convert(this._x /  95.047),\n            y = convert(this._y / 100.000),\n            z = convert(this._z / 108.883);\n\n        return new ONECOLOR.LAB(\n            (116 * y) - 16,\n            500 * (x - y),\n            200 * (y - z),\n            this._alpha\n        );\n    }\n});\n\n/*global INCLUDE, installColorSpace, ONECOLOR*/\n\ninstallColorSpace('LAB', ['l', 'a', 'b', 'alpha'], {\n    fromRgb: function () {\n        return this.xyz().lab();\n    },\n\n    rgb: function () {\n        return this.xyz().rgb();\n    },\n\n    xyz: function () {\n        // http://www.easyrgb.com/index.php?X=MATH&H=08#text8\n        var convert = function (channel) {\n                var pow = Math.pow(channel, 3);\n                return pow > 0.008856 ?\n                    pow :\n                    (channel - 16 / 116) / 7.87;\n            },\n            y = (this._l + 16) / 116,\n            x = this._a / 500 + y,\n            z = y - this._b / 200;\n\n        return new ONECOLOR.XYZ(\n            convert(x) *  95.047,\n            convert(y) * 100.000,\n            convert(z) * 108.883,\n            this._alpha\n        );\n    }\n});\n\n/*global one*/\n\ninstallColorSpace('HSV', ['hue', 'saturation', 'value', 'alpha'], {\n    rgb: function () {\n        var hue = this._hue,\n            saturation = this._saturation,\n            value = this._value,\n            i = Math.min(5, Math.floor(hue * 6)),\n            f = hue * 6 - i,\n            p = value * (1 - saturation),\n            q = value * (1 - f * saturation),\n            t = value * (1 - (1 - f) * saturation),\n            red,\n            green,\n            blue;\n        switch (i) {\n        case 0:\n            red = value;\n            green = t;\n            blue = p;\n            break;\n        case 1:\n            red = q;\n            green = value;\n            blue = p;\n            break;\n        case 2:\n            red = p;\n            green = value;\n            blue = t;\n            break;\n        case 3:\n            red = p;\n            green = q;\n            blue = value;\n            break;\n        case 4:\n            red = t;\n            green = p;\n            blue = value;\n            break;\n        case 5:\n            red = value;\n            green = p;\n            blue = q;\n            break;\n        }\n        return new ONECOLOR.RGB(red, green, blue, this._alpha);\n    },\n\n    hsl: function () {\n        var l = (2 - this._saturation) * this._value,\n            sv = this._saturation * this._value,\n            svDivisor = l <= 1 ? l : (2 - l),\n            saturation;\n\n        // Avoid division by zero when lightness approaches zero:\n        if (svDivisor < 1e-9) {\n            saturation = 0;\n        } else {\n            saturation = sv / svDivisor;\n        }\n        return new ONECOLOR.HSL(this._hue, saturation, l / 2, this._alpha);\n    },\n\n    fromRgb: function () { // Becomes one.color.RGB.prototype.hsv\n        var red = this._red,\n            green = this._green,\n            blue = this._blue,\n            max = Math.max(red, green, blue),\n            min = Math.min(red, green, blue),\n            delta = max - min,\n            hue,\n            saturation = (max === 0) ? 0 : (delta / max),\n            value = max;\n        if (delta === 0) {\n            hue = 0;\n        } else {\n            switch (max) {\n            case red:\n                hue = (green - blue) / delta / 6 + (green < blue ? 1 : 0);\n                break;\n            case green:\n                hue = (blue - red) / delta / 6 + 1 / 3;\n                break;\n            case blue:\n                hue = (red - green) / delta / 6 + 2 / 3;\n                break;\n            }\n        }\n        return new ONECOLOR.HSV(hue, saturation, value, this._alpha);\n    }\n});\n\n/*global one*/\n\n\ninstallColorSpace('HSL', ['hue', 'saturation', 'lightness', 'alpha'], {\n    hsv: function () {\n        // Algorithm adapted from http://wiki.secondlife.com/wiki/Color_conversion_scripts\n        var l = this._lightness * 2,\n            s = this._saturation * ((l <= 1) ? l : 2 - l),\n            saturation;\n\n        // Avoid division by zero when l + s is very small (approaching black):\n        if (l + s < 1e-9) {\n            saturation = 0;\n        } else {\n            saturation = (2 * s) / (l + s);\n        }\n\n        return new ONECOLOR.HSV(this._hue, saturation, (l + s) / 2, this._alpha);\n    },\n\n    rgb: function () {\n        return this.hsv().rgb();\n    },\n\n    fromRgb: function () { // Becomes one.color.RGB.prototype.hsv\n        return this.hsv().hsl();\n    }\n});\n\n/*global one*/\n\ninstallColorSpace('CMYK', ['cyan', 'magenta', 'yellow', 'black', 'alpha'], {\n    rgb: function () {\n        return new ONECOLOR.RGB((1 - this._cyan * (1 - this._black) - this._black),\n                                 (1 - this._magenta * (1 - this._black) - this._black),\n                                 (1 - this._yellow * (1 - this._black) - this._black),\n                                 this._alpha);\n    },\n\n    fromRgb: function () { // Becomes one.color.RGB.prototype.cmyk\n        // Adapted from http://www.javascripter.net/faq/rgb2cmyk.htm\n        var red = this._red,\n            green = this._green,\n            blue = this._blue,\n            cyan = 1 - red,\n            magenta = 1 - green,\n            yellow = 1 - blue,\n            black = 1;\n        if (red || green || blue) {\n            black = Math.min(cyan, Math.min(magenta, yellow));\n            cyan = (cyan - black) / (1 - black);\n            magenta = (magenta - black) / (1 - black);\n            yellow = (yellow - black) / (1 - black);\n        } else {\n            black = 1;\n        }\n        return new ONECOLOR.CMYK(cyan, magenta, yellow, black, this._alpha);\n    }\n});\n\nONECOLOR.installMethod('clearer', function (amount) {\n    return this.alpha(isNaN(amount) ? -0.1 : -amount, true);\n});\n\n\nONECOLOR.installMethod('darken', function (amount) {\n    return this.lightness(isNaN(amount) ? -0.1 : -amount, true);\n});\n\n\nONECOLOR.installMethod('desaturate', function (amount) {\n    return this.saturation(isNaN(amount) ? -0.1 : -amount, true);\n});\n\nfunction gs () {\n    var rgb = this.rgb(),\n        val = rgb._red * 0.3 + rgb._green * 0.59 + rgb._blue * 0.11;\n\n    return new ONECOLOR.RGB(val, val, val, this._alpha);\n};\n\nONECOLOR.installMethod('greyscale', gs);\nONECOLOR.installMethod('grayscale', gs);\n\n\nONECOLOR.installMethod('lighten', function (amount) {\n    return this.lightness(isNaN(amount) ? 0.1 : amount, true);\n});\n\nONECOLOR.installMethod('mix', function (otherColor, weight) {\n    otherColor = ONECOLOR(otherColor).rgb();\n    weight = 1 - (isNaN(weight) ? 0.5 : weight);\n\n    var w = weight * 2 - 1,\n        a = this._alpha - otherColor._alpha,\n        weight1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2,\n        weight2 = 1 - weight1,\n        rgb = this.rgb();\n\n    return new ONECOLOR.RGB(\n        rgb._red * weight1 + otherColor._red * weight2,\n        rgb._green * weight1 + otherColor._green * weight2,\n        rgb._blue * weight1 + otherColor._blue * weight2,\n        rgb._alpha * weight + otherColor._alpha * (1 - weight)\n    );\n});\n\nONECOLOR.installMethod('negate', function () {\n    var rgb = this.rgb();\n    return new ONECOLOR.RGB(1 - rgb._red, 1 - rgb._green, 1 - rgb._blue, this._alpha);\n});\n\nONECOLOR.installMethod('opaquer', function (amount) {\n    return this.alpha(isNaN(amount) ? 0.1 : amount, true);\n});\n\nONECOLOR.installMethod('rotate', function (degrees) {\n    return this.hue((degrees || 0) / 360, true);\n});\n\n\nONECOLOR.installMethod('saturate', function (amount) {\n    return this.saturation(isNaN(amount) ? 0.1 : amount, true);\n});\n\n// Adapted from http://gimp.sourcearchive.com/documentation/2.6.6-1ubuntu1/color-to-alpha_8c-source.html\n/*\n    toAlpha returns a color where the values of the argument have been converted to alpha\n*/\nONECOLOR.installMethod('toAlpha', function (color) {\n    var me = this.rgb(),\n        other = ONECOLOR(color).rgb(),\n        epsilon = 1e-10,\n        a = new ONECOLOR.RGB(0, 0, 0, me._alpha),\n        channels = ['_red', '_green', '_blue'];\n\n    channels.forEach(function (channel) {\n        if (me[channel] < epsilon) {\n            a[channel] = me[channel];\n        } else if (me[channel] > other[channel]) {\n            a[channel] = (me[channel] - other[channel]) / (1 - other[channel]);\n        } else if (me[channel] > other[channel]) {\n            a[channel] = (other[channel] - me[channel]) / other[channel];\n        } else {\n            a[channel] = 0;\n        }\n    });\n\n    if (a._red > a._green) {\n        if (a._red > a._blue) {\n            me._alpha = a._red;\n        } else {\n            me._alpha = a._blue;\n        }\n    } else if (a._green > a._blue) {\n        me._alpha = a._green;\n    } else {\n        me._alpha = a._blue;\n    }\n\n    if (me._alpha < epsilon) {\n        return me;\n    }\n\n    channels.forEach(function (channel) {\n        me[channel] = (me[channel] - other[channel]) / me._alpha + other[channel];\n    });\n    me._alpha *= a._alpha;\n\n    return me;\n});\n\n/*global one*/\n\n// This file is purely for the build system\n\n// Order is important to prevent channel name clashes. Lab <-> hsL\n\n// Convenience functions\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL29uZWNvbG9yL29uZS1jb2xvci1hbGwtZGVidWcuanM/ZWJlYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0EsNEVBQTRFO0FBQzVFLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVMsa0JBQWtCLGtIQUFrSDtBQUM3STtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGFBQWE7QUFDYixnRkFBZ0Y7QUFDaEYsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTLFNBQVMsT0FBTztBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEpBQTBKO0FBQzFKLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxtREFBbUQ7QUFDbkQsY0FBYztBQUNkO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixLQUFLOztBQUVMO0FBQ0E7QUFDQSwrSEFBK0gsR0FBRztBQUNsSTtBQUNBLHdOQUF3TjtBQUN4TixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELElBQUksS0FBNEIsV0FBVyxnR0FBVTtBQUNyRCxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTixDQUFDLFVBQVUsSUFBMkI7QUFDdEM7QUFDQTtBQUNBLENBQUMsTUFBTSxFQUdOOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vbmVjb2xvci9vbmUtY29sb3ItYWxsLWRlYnVnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgZXZpbDp0cnVlLCBvbmV2YXI6ZmFsc2UqL1xuLypnbG9iYWwgZGVmaW5lKi9cbnZhciBpbnN0YWxsZWRDb2xvclNwYWNlcyA9IFtdLFxuICAgIG5hbWVkQ29sb3JzID0ge30sXG4gICAgdW5kZWYgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbiAgICB9LFxuICAgIGNoYW5uZWxSZWdFeHAgPSAvXFxzKihcXC5cXGQrfFxcZCsoPzpcXC5cXGQrKT8pKCUpP1xccyovLFxuICAgIHBlcmNlbnRhZ2VDaGFubmVsUmVnRXhwID0gL1xccyooXFwuXFxkK3wxMDB8XFxkP1xcZCg/OlxcLlxcZCspPyklXFxzKi8sXG4gICAgYWxwaGFDaGFubmVsUmVnRXhwID0gL1xccyooXFwuXFxkK3xcXGQrKD86XFwuXFxkKyk/KVxccyovLFxuICAgIGNzc0NvbG9yUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIl4ocmdifGhzbHxoc3YpYT9cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyBcIixcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxSZWdFeHAuc291cmNlICsgXCIsXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsUmVnRXhwLnNvdXJjZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86LFwiICsgYWxwaGFDaGFubmVsUmVnRXhwLnNvdXJjZSArIFwiKT9cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcKSRcIiwgXCJpXCIpO1xuXG5mdW5jdGlvbiBPTkVDT0xPUihvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgT05FQ09MT1Jbb2JqWzBdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQXNzdW1lZCBhcnJheSBmcm9tIC50b0pTT04oKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPTkVDT0xPUltvYmpbMF1dKG9iai5zbGljZSgxLCBvYmoubGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gQXNzdW1lZCA0IGVsZW1lbnQgaW50IFJHQiBhcnJheSBmcm9tIGNhbnZhcyB3aXRoIGFsbCBjaGFubmVscyBbMDsyNTVdXG4gICAgICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlJHQihvYmpbMF0gLyAyNTUsIG9ialsxXSAvIDI1NSwgb2JqWzJdIC8gMjU1LCBvYmpbM10gLyAyNTUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbG93ZXJDYXNlZCA9IG9iai50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobmFtZWRDb2xvcnNbbG93ZXJDYXNlZF0pIHtcbiAgICAgICAgICAgIG9iaiA9ICcjJyArIG5hbWVkQ29sb3JzW2xvd2VyQ2FzZWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlckNhc2VkID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICBvYmogPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBmb3IgQ1NTIHJnYiguLi4uKSBzdHJpbmdcbiAgICAgICAgdmFyIG1hdGNoQ3NzU3ludGF4ID0gb2JqLm1hdGNoKGNzc0NvbG9yUmVnRXhwKTtcbiAgICAgICAgaWYgKG1hdGNoQ3NzU3ludGF4KSB7XG4gICAgICAgICAgICB2YXIgY29sb3JTcGFjZU5hbWUgPSBtYXRjaENzc1N5bnRheFsxXS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIGFscGhhID0gdW5kZWYobWF0Y2hDc3NTeW50YXhbOF0pID8gbWF0Y2hDc3NTeW50YXhbOF0gOiBwYXJzZUZsb2F0KG1hdGNoQ3NzU3ludGF4WzhdKSxcbiAgICAgICAgICAgICAgICBoYXNIdWUgPSBjb2xvclNwYWNlTmFtZVswXSA9PT0gJ0gnLFxuICAgICAgICAgICAgICAgIGZpcnN0Q2hhbm5lbERpdmlzb3IgPSBtYXRjaENzc1N5bnRheFszXSA/IDEwMCA6IChoYXNIdWUgPyAzNjAgOiAyNTUpLFxuICAgICAgICAgICAgICAgIHNlY29uZENoYW5uZWxEaXZpc29yID0gKG1hdGNoQ3NzU3ludGF4WzVdIHx8IGhhc0h1ZSkgPyAxMDAgOiAyNTUsXG4gICAgICAgICAgICAgICAgdGhpcmRDaGFubmVsRGl2aXNvciA9IChtYXRjaENzc1N5bnRheFs3XSB8fCBoYXNIdWUpID8gMTAwIDogMjU1O1xuICAgICAgICAgICAgaWYgKHVuZGVmKE9ORUNPTE9SW2NvbG9yU3BhY2VOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmUuY29sb3IuXCIgKyBjb2xvclNwYWNlTmFtZSArIFwiIGlzIG5vdCBpbnN0YWxsZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPTkVDT0xPUltjb2xvclNwYWNlTmFtZV0oXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChtYXRjaENzc1N5bnRheFsyXSkgLyBmaXJzdENoYW5uZWxEaXZpc29yLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobWF0Y2hDc3NTeW50YXhbNF0pIC8gc2Vjb25kQ2hhbm5lbERpdmlzb3IsXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChtYXRjaENzc1N5bnRheFs2XSkgLyB0aGlyZENoYW5uZWxEaXZpc29yLFxuICAgICAgICAgICAgICAgIGFscGhhXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc3VtZSBoZXggc3ludGF4XG4gICAgICAgIGlmIChvYmoubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgLy8gQWxsb3cgQ1NTIHNob3J0aGFuZFxuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL14jPyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaSwgJyQxJDEkMiQyJDMkMycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwbGl0IG9iaiBpbnRvIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGhleE1hdGNoID0gb2JqLm1hdGNoKC9eIz8oWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkkL2kpO1xuICAgICAgICBpZiAoaGV4TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT05FQ09MT1IuUkdCKFxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGhleE1hdGNoWzFdLCAxNikgLyAyNTUsXG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoaGV4TWF0Y2hbMl0sIDE2KSAvIDI1NSxcbiAgICAgICAgICAgICAgICBwYXJzZUludChoZXhNYXRjaFszXSwgMTYpIC8gMjU1XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gbWF0Y2ggc28gZmFyLiBMZXRzIHRyeSB0aGUgbGVzcyBsaWtlbHkgb25lc1xuICAgICAgICBpZiAoT05FQ09MT1IuQ01ZSykge1xuICAgICAgICAgICAgdmFyIGNteWtNYXRjaCA9IG9iai5tYXRjaChuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl5jbXlrXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcXFwoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgXCIsXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgXCIsXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgXCIsXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXFxcKSRcIiwgXCJpXCIpKTtcbiAgICAgICAgICAgIGlmIChjbXlrTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLkNNWUsoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY215a01hdGNoWzFdKSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjbXlrTWF0Y2hbMl0pIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNteWtNYXRjaFszXSkgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY215a01hdGNoWzRdKSAvIDEwMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5pc0NvbG9yKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbG9yU3BhY2UoY29sb3JTcGFjZU5hbWUsIHByb3BlcnR5TmFtZXMsIGNvbmZpZykge1xuICAgIE9ORUNPTE9SW2NvbG9yU3BhY2VOYW1lXSA9IG5ldyBGdW5jdGlvbihwcm9wZXJ0eU5hbWVzLmpvaW4oXCIsXCIpLFxuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIGFuIGFycmF5IHRvIHRoZSBjb25zdHJ1Y3RvcjpcbiAgICAgICAgXCJpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShcIiArIHByb3BlcnR5TmFtZXNbMF0gKyBcIikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcIiArXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5TmFtZSArIFwiPVwiICsgcHJvcGVydHlOYW1lc1swXSArIFwiW1wiICsgaSArIFwiXTtcIjtcbiAgICAgICAgICAgIH0pLnJldmVyc2UoKS5qb2luKFwiXCIpICtcbiAgICAgICAgXCJ9XCIgK1xuICAgICAgICBcImlmIChcIiArIHByb3BlcnR5TmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eU5hbWUgIT09ICdhbHBoYSc7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpc05hTihcIiArIHByb3BlcnR5TmFtZSArIFwiKVwiO1xuICAgICAgICB9KS5qb2luKFwifHxcIikgKyBcIil7XCIgKyBcInRocm93IG5ldyBFcnJvcihcXFwiW1wiICsgY29sb3JTcGFjZU5hbWUgKyBcIl06IEludmFsaWQgY29sb3I6IChcXFwiK1wiICsgcHJvcGVydHlOYW1lcy5qb2luKFwiK1xcXCIsXFxcIitcIikgKyBcIitcXFwiKVxcXCIpO31cIiArXG4gICAgICAgIHByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdodWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidGhpcy5faHVlPWh1ZTwwP2h1ZS1NYXRoLmZsb29yKGh1ZSk6aHVlJTFcIjsgLy8gV3JhcFxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdhbHBoYScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0aGlzLl9hbHBoYT0oaXNOYU4oYWxwaGEpfHxhbHBoYT4xKT8xOihhbHBoYTwwPzA6YWxwaGEpO1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0aGlzLl9cIiArIHByb3BlcnR5TmFtZSArIFwiPVwiICsgcHJvcGVydHlOYW1lICsgXCI8MD8wOihcIiArIHByb3BlcnR5TmFtZSArIFwiPjE/MTpcIiArIHByb3BlcnR5TmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiO1wiKSArIFwiO1wiXG4gICAgKTtcbiAgICBPTkVDT0xPUltjb2xvclNwYWNlTmFtZV0ucHJvcGVydHlOYW1lcyA9IHByb3BlcnR5TmFtZXM7XG5cbiAgICB2YXIgcHJvdG90eXBlID0gT05FQ09MT1JbY29sb3JTcGFjZU5hbWVdLnByb3RvdHlwZTtcblxuICAgIFsndmFsdWVPZicsICdoZXgnLCAnaGV4YScsICdjc3MnLCAnY3NzYSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcHJvdG90eXBlW21ldGhvZE5hbWVdID0gcHJvdG90eXBlW21ldGhvZE5hbWVdIHx8IChjb2xvclNwYWNlTmFtZSA9PT0gJ1JHQicgPyBwcm90b3R5cGUuaGV4IDogbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXMucmdiKCkuXCIgKyBtZXRob2ROYW1lICsgXCIoKTtcIikpO1xuICAgIH0pO1xuXG4gICAgcHJvdG90eXBlLmlzQ29sb3IgPSB0cnVlO1xuXG4gICAgcHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlckNvbG9yLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmICh1bmRlZihlcHNpbG9uKSkge1xuICAgICAgICAgICAgZXBzaWxvbiA9IDFlLTEwO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJDb2xvciA9IG90aGVyQ29sb3JbY29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKV0oKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzWydfJyArIHByb3BlcnR5TmFtZXNbaV1dIC0gb3RoZXJDb2xvclsnXycgKyBwcm9wZXJ0eU5hbWVzW2ldXSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHByb3RvdHlwZS50b0pTT04gPSBuZXcgRnVuY3Rpb24oXG4gICAgICAgIFwicmV0dXJuIFsnXCIgKyBjb2xvclNwYWNlTmFtZSArIFwiJywgXCIgK1xuICAgICAgICAgICAgcHJvcGVydHlOYW1lcy5tYXAoZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInRoaXMuX1wiICsgcHJvcGVydHlOYW1lO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbihcIiwgXCIpICtcbiAgICAgICAgXCJdO1wiXG4gICAgKTtcblxuICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hGcm9tQ29sb3JTcGFjZSA9IHByb3BlcnR5TmFtZS5tYXRjaCgvXmZyb20oLiopJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoRnJvbUNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBPTkVDT0xPUlttYXRjaEZyb21Db2xvclNwYWNlWzFdLnRvVXBwZXJDYXNlKCldLnByb3RvdHlwZVtjb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGNvbmZpZ1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGVbcHJvcGVydHlOYW1lXSA9IGNvbmZpZ1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSXQgaXMgcHJldHR5IGVhc3kgdG8gaW1wbGVtZW50IHRoZSBjb252ZXJzaW9uIHRvIHRoZSBzYW1lIGNvbG9yIHNwYWNlOlxuICAgIHByb3RvdHlwZVtjb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBwcm90b3R5cGUudG9TdHJpbmcgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXFxcIltvbmUuY29sb3IuXCIgKyBjb2xvclNwYWNlTmFtZSArIFwiOlxcXCIrXCIgKyBwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBpKSB7XG4gICAgICAgIHJldHVybiBcIlxcXCIgXCIgKyBwcm9wZXJ0eU5hbWVzW2ldICsgXCI9XFxcIit0aGlzLl9cIiArIHByb3BlcnR5TmFtZTtcbiAgICB9KS5qb2luKFwiK1wiKSArIFwiK1xcXCJdXFxcIjtcIik7XG5cbiAgICAvLyBHZW5lcmF0ZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGkpIHtcbiAgICAgICAgcHJvdG90eXBlW3Byb3BlcnR5TmFtZV0gPSBwcm90b3R5cGVbcHJvcGVydHlOYW1lID09PSAnYmxhY2snID8gJ2snIDogcHJvcGVydHlOYW1lWzBdXSA9IG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaXNEZWx0YVwiLFxuICAgICAgICAgICAgLy8gU2ltcGxlIGdldHRlciBtb2RlOiBjb2xvci5yZWQoKVxuICAgICAgICAgICAgXCJpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1wiICtcbiAgICAgICAgICAgICAgICBcInJldHVybiB0aGlzLl9cIiArIHByb3BlcnR5TmFtZSArIFwiO1wiICtcbiAgICAgICAgICAgIFwifVwiICtcbiAgICAgICAgICAgIC8vIEFkanVzdGVyOiBjb2xvci5yZWQoKy4yLCB0cnVlKVxuICAgICAgICAgICAgXCJpZiAoaXNEZWx0YSkge1wiICtcbiAgICAgICAgICAgICAgICBcInJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcIiArIHByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChvdGhlclByb3BlcnR5TmFtZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0aGlzLl9cIiArIG90aGVyUHJvcGVydHlOYW1lICsgKHByb3BlcnR5TmFtZSA9PT0gb3RoZXJQcm9wZXJ0eU5hbWUgPyBcIit2YWx1ZVwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIpO1wiICtcbiAgICAgICAgICAgIFwifVwiICtcbiAgICAgICAgICAgIC8vIFNldHRlcjogY29sb3IucmVkKC4yKTtcbiAgICAgICAgICAgIFwicmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKFwiICsgcHJvcGVydHlOYW1lcy5tYXAoZnVuY3Rpb24gKG90aGVyUHJvcGVydHlOYW1lLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5TmFtZSA9PT0gb3RoZXJQcm9wZXJ0eU5hbWUgPyBcInZhbHVlXCIgOiBcInRoaXMuX1wiICsgb3RoZXJQcm9wZXJ0eU5hbWU7XG4gICAgICAgICAgICB9KS5qb2luKFwiLCBcIikgKyBcIik7XCIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaW5zdGFsbEZvcmVpZ25NZXRob2RzKHRhcmdldENvbG9yU3BhY2VOYW1lLCBzb3VyY2VDb2xvclNwYWNlTmFtZSkge1xuICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgIG9ialtzb3VyY2VDb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzLnJnYigpLlwiICsgc291cmNlQ29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKSArIFwiKCk7XCIpOyAvLyBGYWxsYmFja1xuICAgICAgICBPTkVDT0xPUltzb3VyY2VDb2xvclNwYWNlTmFtZV0ucHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGkpIHtcbiAgICAgICAgICAgIG9ialtwcm9wZXJ0eU5hbWVdID0gb2JqW3Byb3BlcnR5TmFtZSA9PT0gJ2JsYWNrJyA/ICdrJyA6IHByb3BlcnR5TmFtZVswXV0gPSBuZXcgRnVuY3Rpb24oXCJ2YWx1ZVwiLCBcImlzRGVsdGFcIiwgXCJyZXR1cm4gdGhpcy5cIiArIHNvdXJjZUNvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCkgKyBcIigpLlwiICsgcHJvcGVydHlOYW1lICsgXCIodmFsdWUsIGlzRGVsdGEpO1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIE9ORUNPTE9SW3RhcmdldENvbG9yU3BhY2VOYW1lXS5wcm90b3R5cGVbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9ORUNPTE9SW3RhcmdldENvbG9yU3BhY2VOYW1lXS5wcm90b3R5cGVbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YWxsZWRDb2xvclNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChvdGhlckNvbG9yU3BhY2VOYW1lKSB7XG4gICAgICAgIGluc3RhbGxGb3JlaWduTWV0aG9kcyhjb2xvclNwYWNlTmFtZSwgb3RoZXJDb2xvclNwYWNlTmFtZSk7XG4gICAgICAgIGluc3RhbGxGb3JlaWduTWV0aG9kcyhvdGhlckNvbG9yU3BhY2VOYW1lLCBjb2xvclNwYWNlTmFtZSk7XG4gICAgfSk7XG5cbiAgICBpbnN0YWxsZWRDb2xvclNwYWNlcy5wdXNoKGNvbG9yU3BhY2VOYW1lKTtcbn1cblxuT05FQ09MT1IuaW5zdGFsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIGluc3RhbGxlZENvbG9yU3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yU3BhY2UpIHtcbiAgICAgICAgT05FQ09MT1JbY29sb3JTcGFjZV0ucHJvdG90eXBlW25hbWVdID0gZm47XG4gICAgfSk7XG59O1xuXG5pbnN0YWxsQ29sb3JTcGFjZSgnUkdCJywgWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICdhbHBoYSddLCB7XG4gICAgaGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZXhTdHJpbmcgPSAoTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9yZWQpICogMHgxMDAwMCArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fZ3JlZW4pICogMHgxMDAgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2JsdWUpKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiAnIycgKyAoJzAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleFN0cmluZy5sZW5ndGgpKSArIGhleFN0cmluZztcbiAgICB9LFxuXG4gICAgaGV4YTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWxwaGFTdHJpbmcgPSBNYXRoLnJvdW5kKHRoaXMuX2FscGhhICogMjU1KS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiAnIycgKyAnMDAnLnN1YnN0cigwLCAyIC0gYWxwaGFTdHJpbmcubGVuZ3RoKSArIGFscGhhU3RyaW5nICsgdGhpcy5oZXgoKS5zdWJzdHIoMSwgNik7XG4gICAgfSxcblxuICAgIGNzczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJyZ2IoXCIgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX3JlZCkgKyBcIixcIiArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fZ3JlZW4pICsgXCIsXCIgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2JsdWUpICsgXCIpXCI7XG4gICAgfSxcblxuICAgIGNzc2E6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fcmVkKSArIFwiLFwiICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9ncmVlbikgKyBcIixcIiArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fYmx1ZSkgKyBcIixcIiArIHRoaXMuX2FscGhhICsgXCIpXCI7XG4gICAgfVxufSk7XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdW5kZWYoZGVmaW5lLmFtZCkpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT05FQ09MT1I7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUgbW9kdWxlIGV4cG9ydFxuICAgIG1vZHVsZS5leHBvcnRzID0gT05FQ09MT1I7XG59IGVsc2Uge1xuICAgIG9uZSA9IHdpbmRvdy5vbmUgfHwge307XG4gICAgb25lLmNvbG9yID0gT05FQ09MT1I7XG59XG5cbmlmICh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyAmJiB1bmRlZihqUXVlcnkuY29sb3IpKSB7XG4gICAgalF1ZXJ5LmNvbG9yID0gT05FQ09MT1I7XG59XG5cbi8qZ2xvYmFsIG5hbWVkQ29sb3JzKi9cbm5hbWVkQ29sb3JzID0ge1xuICAgIGFsaWNlYmx1ZTogJ2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgICBhcXVhOiAnMGZmJyxcbiAgICBhcXVhbWFyaW5lOiAnN2ZmZmQ0JyxcbiAgICBhenVyZTogJ2YwZmZmZicsXG4gICAgYmVpZ2U6ICdmNWY1ZGMnLFxuICAgIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcwMDAnLFxuICAgIGJsYW5jaGVkYWxtb25kOiAnZmZlYmNkJyxcbiAgICBibHVlOiAnMDBmJyxcbiAgICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgICBicm93bjogJ2E1MmEyYScsXG4gICAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICAgIGNoYXJ0cmV1c2U6ICc3ZmZmMDAnLFxuICAgIGNob2NvbGF0ZTogJ2QyNjkxZScsXG4gICAgY29yYWw6ICdmZjdmNTAnLFxuICAgIGNvcm5mbG93ZXJibHVlOiAnNjQ5NWVkJyxcbiAgICBjb3Juc2lsazogJ2ZmZjhkYycsXG4gICAgY3JpbXNvbjogJ2RjMTQzYycsXG4gICAgY3lhbjogJzBmZicsXG4gICAgZGFya2JsdWU6ICcwMDAwOGInLFxuICAgIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgICBkYXJrZ29sZGVucm9kOiAnYjg4NjBiJyxcbiAgICBkYXJrZ3JheTogJ2E5YTlhOScsXG4gICAgZGFya2dyZXk6ICdhOWE5YTknLFxuICAgIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gICAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gICAgZGFya29saXZlZ3JlZW46ICc1NTZiMmYnLFxuICAgIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICAgIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICAgIGRhcmtyZWQ6ICc4YjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICAgIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gICAgZGFya3NsYXRlYmx1ZTogJzQ4M2Q4YicsXG4gICAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gICAgZGFya3NsYXRlZ3JleTogJzJmNGY0ZicsXG4gICAgZGFya3R1cnF1b2lzZTogJzAwY2VkMScsXG4gICAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gICAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICAgIGRlZXBza3libHVlOiAnMDBiZmZmJyxcbiAgICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgICBkaW1ncmV5OiAnNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAnMWU5MGZmJyxcbiAgICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICAgIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgICBmb3Jlc3RncmVlbjogJzIyOGIyMicsXG4gICAgZnVjaHNpYTogJ2YwZicsXG4gICAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgICBnaG9zdHdoaXRlOiAnZjhmOGZmJyxcbiAgICBnb2xkOiAnZmZkNzAwJyxcbiAgICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICAgIGdyYXk6ICc4MDgwODAnLFxuICAgIGdyZXk6ICc4MDgwODAnLFxuICAgIGdyZWVuOiAnMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gICAgaG9uZXlkZXc6ICdmMGZmZjAnLFxuICAgIGhvdHBpbms6ICdmZjY5YjQnLFxuICAgIGluZGlhbnJlZDogJ2NkNWM1YycsXG4gICAgaW5kaWdvOiAnNGIwMDgyJyxcbiAgICBpdm9yeTogJ2ZmZmZmMCcsXG4gICAga2hha2k6ICdmMGU2OGMnLFxuICAgIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgICBsYXduZ3JlZW46ICc3Y2ZjMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gICAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgICBsaWdodGNvcmFsOiAnZjA4MDgwJyxcbiAgICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgICBsaWdodGdyYXk6ICdkM2QzZDMnLFxuICAgIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gICAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gICAgbGlnaHRwaW5rOiAnZmZiNmMxJyxcbiAgICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gICAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gICAgbGlnaHRza3libHVlOiAnODdjZWZhJyxcbiAgICBsaWdodHNsYXRlZ3JheTogJzc4OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICc3ODknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAnYjBjNGRlJyxcbiAgICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gICAgbGltZTogJzBmMCcsXG4gICAgbGltZWdyZWVuOiAnMzJjZDMyJyxcbiAgICBsaW5lbjogJ2ZhZjBlNicsXG4gICAgbWFnZW50YTogJ2YwZicsXG4gICAgbWFyb29uOiAnODAwMDAwJyxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICdiYTU1ZDMnLFxuICAgIG1lZGl1bXB1cnBsZTogJzkzNzBkOCcsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogJzdiNjhlZScsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAnYzcxNTg1JyxcbiAgICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gICAgbWlzdHlyb3NlOiAnZmZlNGUxJyxcbiAgICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gICAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICAgIG5hdnk6ICcwMDAwODAnLFxuICAgIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICAgIG9saXZlOiAnODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICc2YjhlMjMnLFxuICAgIG9yYW5nZTogJ2ZmYTUwMCcsXG4gICAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgICBvcmNoaWQ6ICdkYTcwZDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICAgIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gICAgcGFsZXR1cnF1b2lzZTogJ2FmZWVlZScsXG4gICAgcGFsZXZpb2xldHJlZDogJ2Q4NzA5MycsXG4gICAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gICAgcGVhY2hwdWZmOiAnZmZkYWI5JyxcbiAgICBwZXJ1OiAnY2Q4NTNmJyxcbiAgICBwaW5rOiAnZmZjMGNiJyxcbiAgICBwbHVtOiAnZGRhMGRkJyxcbiAgICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgICBwdXJwbGU6ICc4MDAwODAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICc2MzknLFxuICAgIHJlZDogJ2YwMCcsXG4gICAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgICByb3lhbGJsdWU6ICc0MTY5ZTEnLFxuICAgIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgICBzYWxtb246ICdmYTgwNzInLFxuICAgIHNhbmR5YnJvd246ICdmNGE0NjAnLFxuICAgIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gICAgc2llbm5hOiAnYTA1MjJkJyxcbiAgICBzaWx2ZXI6ICdjMGMwYzAnLFxuICAgIHNreWJsdWU6ICc4N2NlZWInLFxuICAgIHNsYXRlYmx1ZTogJzZhNWFjZCcsXG4gICAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgICBzbGF0ZWdyZXk6ICc3MDgwOTAnLFxuICAgIHNub3c6ICdmZmZhZmEnLFxuICAgIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICAgIHRhbjogJ2QyYjQ4YycsXG4gICAgdGVhbDogJzAwODA4MCcsXG4gICAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gICAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICAgIHZpb2xldDogJ2VlODJlZScsXG4gICAgd2hlYXQ6ICdmNWRlYjMnLFxuICAgIHdoaXRlOiAnZmZmJyxcbiAgICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgICB5ZWxsb3c6ICdmZjAnLFxuICAgIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xufTtcblxuLypnbG9iYWwgSU5DTFVERSwgaW5zdGFsbENvbG9yU3BhY2UsIE9ORUNPTE9SKi9cblxuaW5zdGFsbENvbG9yU3BhY2UoJ1hZWicsIFsneCcsICd5JywgJ3onLCAnYWxwaGEnXSwge1xuICAgIGZyb21SZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9pbmRleC5waHA/WD1NQVRIJkg9MDIjdGV4dDJcbiAgICAgICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsID4gMC4wNDA0NSA/XG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KChjaGFubmVsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsIC8gMTIuOTI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgciA9IGNvbnZlcnQodGhpcy5fcmVkKSxcbiAgICAgICAgICAgIGcgPSBjb252ZXJ0KHRoaXMuX2dyZWVuKSxcbiAgICAgICAgICAgIGIgPSBjb252ZXJ0KHRoaXMuX2JsdWUpO1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSB3aGl0ZSBwb2ludCBzUkdCIEQ2NTpcbiAgICAgICAgLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlhZWihcbiAgICAgICAgICAgIHIgKiAwLjQxMjQ1NjQgKyBnICogMC4zNTc1NzYxICsgYiAqIDAuMTgwNDM3NSxcbiAgICAgICAgICAgIHIgKiAwLjIxMjY3MjkgKyBnICogMC43MTUxNTIyICsgYiAqIDAuMDcyMTc1MCxcbiAgICAgICAgICAgIHIgKiAwLjAxOTMzMzkgKyBnICogMC4xMTkxOTIwICsgYiAqIDAuOTUwMzA0MSxcbiAgICAgICAgICAgIHRoaXMuX2FscGhhXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LmVhc3lyZ2IuY29tL2luZGV4LnBocD9YPU1BVEgmSD0wMSN0ZXh0MVxuICAgICAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgICAgIHogPSB0aGlzLl96LFxuICAgICAgICAgICAgY29udmVydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWwgPiAwLjAwMzEzMDggP1xuICAgICAgICAgICAgICAgICAgICAxLjA1NSAqIE1hdGgucG93KGNoYW5uZWwsIDEgLyAyLjQpIC0gMC4wNTUgOlxuICAgICAgICAgICAgICAgICAgICAxMi45MiAqIGNoYW5uZWw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSB3aGl0ZSBwb2ludCBzUkdCIEQ2NTpcbiAgICAgICAgLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlJHQihcbiAgICAgICAgICAgIGNvbnZlcnQoeCAqICAzLjI0MDQ1NDIgKyB5ICogLTEuNTM3MTM4NSArIHogKiAtMC40OTg1MzE0KSxcbiAgICAgICAgICAgIGNvbnZlcnQoeCAqIC0wLjk2OTI2NjAgKyB5ICogIDEuODc2MDEwOCArIHogKiAgMC4wNDE1NTYwKSxcbiAgICAgICAgICAgIGNvbnZlcnQoeCAqICAwLjA1NTY0MzQgKyB5ICogLTAuMjA0MDI1OSArIHogKiAgMS4wNTcyMjUyKSxcbiAgICAgICAgICAgIHRoaXMuX2FscGhhXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGxhYjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LmVhc3lyZ2IuY29tL2luZGV4LnBocD9YPU1BVEgmSD0wNyN0ZXh0N1xuICAgICAgICB2YXIgY29udmVydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWwgPiAwLjAwODg1NiA/XG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KGNoYW5uZWwsIDEgLyAzKSA6XG4gICAgICAgICAgICAgICAgICAgIDcuNzg3MDM3ICogY2hhbm5lbCArIDQgLyAyOTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4ID0gY29udmVydCh0aGlzLl94IC8gIDk1LjA0NyksXG4gICAgICAgICAgICB5ID0gY29udmVydCh0aGlzLl95IC8gMTAwLjAwMCksXG4gICAgICAgICAgICB6ID0gY29udmVydCh0aGlzLl96IC8gMTA4Ljg4Myk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBPTkVDT0xPUi5MQUIoXG4gICAgICAgICAgICAoMTE2ICogeSkgLSAxNixcbiAgICAgICAgICAgIDUwMCAqICh4IC0geSksXG4gICAgICAgICAgICAyMDAgKiAoeSAtIHopLFxuICAgICAgICAgICAgdGhpcy5fYWxwaGFcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuLypnbG9iYWwgSU5DTFVERSwgaW5zdGFsbENvbG9yU3BhY2UsIE9ORUNPTE9SKi9cblxuaW5zdGFsbENvbG9yU3BhY2UoJ0xBQicsIFsnbCcsICdhJywgJ2InLCAnYWxwaGEnXSwge1xuICAgIGZyb21SZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueHl6KCkubGFiKCk7XG4gICAgfSxcblxuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54eXooKS5yZ2IoKTtcbiAgICB9LFxuXG4gICAgeHl6OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA4I3RleHQ4XG4gICAgICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coY2hhbm5lbCwgMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvdyA+IDAuMDA4ODU2ID9cbiAgICAgICAgICAgICAgICAgICAgcG93IDpcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5uZWwgLSAxNiAvIDExNikgLyA3Ljg3O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHkgPSAodGhpcy5fbCArIDE2KSAvIDExNixcbiAgICAgICAgICAgIHggPSB0aGlzLl9hIC8gNTAwICsgeSxcbiAgICAgICAgICAgIHogPSB5IC0gdGhpcy5fYiAvIDIwMDtcblxuICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlhZWihcbiAgICAgICAgICAgIGNvbnZlcnQoeCkgKiAgOTUuMDQ3LFxuICAgICAgICAgICAgY29udmVydCh5KSAqIDEwMC4wMDAsXG4gICAgICAgICAgICBjb252ZXJ0KHopICogMTA4Ljg4MyxcbiAgICAgICAgICAgIHRoaXMuX2FscGhhXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbi8qZ2xvYmFsIG9uZSovXG5cbmluc3RhbGxDb2xvclNwYWNlKCdIU1YnLCBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ3ZhbHVlJywgJ2FscGhhJ10sIHtcbiAgICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGh1ZSA9IHRoaXMuX2h1ZSxcbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSB0aGlzLl9zYXR1cmF0aW9uLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92YWx1ZSxcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbig1LCBNYXRoLmZsb29yKGh1ZSAqIDYpKSxcbiAgICAgICAgICAgIGYgPSBodWUgKiA2IC0gaSxcbiAgICAgICAgICAgIHAgPSB2YWx1ZSAqICgxIC0gc2F0dXJhdGlvbiksXG4gICAgICAgICAgICBxID0gdmFsdWUgKiAoMSAtIGYgKiBzYXR1cmF0aW9uKSxcbiAgICAgICAgICAgIHQgPSB2YWx1ZSAqICgxIC0gKDEgLSBmKSAqIHNhdHVyYXRpb24pLFxuICAgICAgICAgICAgcmVkLFxuICAgICAgICAgICAgZ3JlZW4sXG4gICAgICAgICAgICBibHVlO1xuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVkID0gdmFsdWU7XG4gICAgICAgICAgICBncmVlbiA9IHQ7XG4gICAgICAgICAgICBibHVlID0gcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZWQgPSBxO1xuICAgICAgICAgICAgZ3JlZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGJsdWUgPSBwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJlZCA9IHA7XG4gICAgICAgICAgICBncmVlbiA9IHZhbHVlO1xuICAgICAgICAgICAgYmx1ZSA9IHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVkID0gcDtcbiAgICAgICAgICAgIGdyZWVuID0gcTtcbiAgICAgICAgICAgIGJsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZWQgPSB0O1xuICAgICAgICAgICAgZ3JlZW4gPSBwO1xuICAgICAgICAgICAgYmx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJlZCA9IHZhbHVlO1xuICAgICAgICAgICAgZ3JlZW4gPSBwO1xuICAgICAgICAgICAgYmx1ZSA9IHE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlJHQihyZWQsIGdyZWVuLCBibHVlLCB0aGlzLl9hbHBoYSk7XG4gICAgfSxcblxuICAgIGhzbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbCA9ICgyIC0gdGhpcy5fc2F0dXJhdGlvbikgKiB0aGlzLl92YWx1ZSxcbiAgICAgICAgICAgIHN2ID0gdGhpcy5fc2F0dXJhdGlvbiAqIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgc3ZEaXZpc29yID0gbCA8PSAxID8gbCA6ICgyIC0gbCksXG4gICAgICAgICAgICBzYXR1cmF0aW9uO1xuXG4gICAgICAgIC8vIEF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hlbiBsaWdodG5lc3MgYXBwcm9hY2hlcyB6ZXJvOlxuICAgICAgICBpZiAoc3ZEaXZpc29yIDwgMWUtOSkge1xuICAgICAgICAgICAgc2F0dXJhdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gc3YgLyBzdkRpdmlzb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPTkVDT0xPUi5IU0wodGhpcy5faHVlLCBzYXR1cmF0aW9uLCBsIC8gMiwgdGhpcy5fYWxwaGEpO1xuICAgIH0sXG5cbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7IC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuaHN2XG4gICAgICAgIHZhciByZWQgPSB0aGlzLl9yZWQsXG4gICAgICAgICAgICBncmVlbiA9IHRoaXMuX2dyZWVuLFxuICAgICAgICAgICAgYmx1ZSA9IHRoaXMuX2JsdWUsXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKSxcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpLFxuICAgICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICBodWUsXG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gKG1heCA9PT0gMCkgPyAwIDogKGRlbHRhIC8gbWF4KSxcbiAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIGh1ZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSAvIDYgKyAoZ3JlZW4gPCBibHVlID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBncmVlbjpcbiAgICAgICAgICAgICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSAvIDYgKyAxIC8gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYmx1ZTpcbiAgICAgICAgICAgICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgLyA2ICsgMiAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPTkVDT0xPUi5IU1YoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSwgdGhpcy5fYWxwaGEpO1xuICAgIH1cbn0pO1xuXG4vKmdsb2JhbCBvbmUqL1xuXG5cbmluc3RhbGxDb2xvclNwYWNlKCdIU0wnLCBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcycsICdhbHBoYSddLCB7XG4gICAgaHN2OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFsZ29yaXRobSBhZGFwdGVkIGZyb20gaHR0cDovL3dpa2kuc2Vjb25kbGlmZS5jb20vd2lraS9Db2xvcl9jb252ZXJzaW9uX3NjcmlwdHNcbiAgICAgICAgdmFyIGwgPSB0aGlzLl9saWdodG5lc3MgKiAyLFxuICAgICAgICAgICAgcyA9IHRoaXMuX3NhdHVyYXRpb24gKiAoKGwgPD0gMSkgPyBsIDogMiAtIGwpLFxuICAgICAgICAgICAgc2F0dXJhdGlvbjtcblxuICAgICAgICAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gbCArIHMgaXMgdmVyeSBzbWFsbCAoYXBwcm9hY2hpbmcgYmxhY2spOlxuICAgICAgICBpZiAobCArIHMgPCAxZS05KSB7XG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhdHVyYXRpb24gPSAoMiAqIHMpIC8gKGwgKyBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgT05FQ09MT1IuSFNWKHRoaXMuX2h1ZSwgc2F0dXJhdGlvbiwgKGwgKyBzKSAvIDIsIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuXG4gICAgcmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhzdigpLnJnYigpO1xuICAgIH0sXG5cbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7IC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuaHN2XG4gICAgICAgIHJldHVybiB0aGlzLmhzdigpLmhzbCgpO1xuICAgIH1cbn0pO1xuXG4vKmdsb2JhbCBvbmUqL1xuXG5pbnN0YWxsQ29sb3JTcGFjZSgnQ01ZSycsIFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjaycsICdhbHBoYSddLCB7XG4gICAgcmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT05FQ09MT1IuUkdCKCgxIC0gdGhpcy5fY3lhbiAqICgxIC0gdGhpcy5fYmxhY2spIC0gdGhpcy5fYmxhY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDEgLSB0aGlzLl9tYWdlbnRhICogKDEgLSB0aGlzLl9ibGFjaykgLSB0aGlzLl9ibGFjayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMSAtIHRoaXMuX3llbGxvdyAqICgxIC0gdGhpcy5fYmxhY2spIC0gdGhpcy5fYmxhY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxwaGEpO1xuICAgIH0sXG5cbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7IC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuY215a1xuICAgICAgICAvLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyY215ay5odG1cbiAgICAgICAgdmFyIHJlZCA9IHRoaXMuX3JlZCxcbiAgICAgICAgICAgIGdyZWVuID0gdGhpcy5fZ3JlZW4sXG4gICAgICAgICAgICBibHVlID0gdGhpcy5fYmx1ZSxcbiAgICAgICAgICAgIGN5YW4gPSAxIC0gcmVkLFxuICAgICAgICAgICAgbWFnZW50YSA9IDEgLSBncmVlbixcbiAgICAgICAgICAgIHllbGxvdyA9IDEgLSBibHVlLFxuICAgICAgICAgICAgYmxhY2sgPSAxO1xuICAgICAgICBpZiAocmVkIHx8IGdyZWVuIHx8IGJsdWUpIHtcbiAgICAgICAgICAgIGJsYWNrID0gTWF0aC5taW4oY3lhbiwgTWF0aC5taW4obWFnZW50YSwgeWVsbG93KSk7XG4gICAgICAgICAgICBjeWFuID0gKGN5YW4gLSBibGFjaykgLyAoMSAtIGJsYWNrKTtcbiAgICAgICAgICAgIG1hZ2VudGEgPSAobWFnZW50YSAtIGJsYWNrKSAvICgxIC0gYmxhY2spO1xuICAgICAgICAgICAgeWVsbG93ID0gKHllbGxvdyAtIGJsYWNrKSAvICgxIC0gYmxhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmxhY2sgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT05FQ09MT1IuQ01ZSyhjeWFuLCBtYWdlbnRhLCB5ZWxsb3csIGJsYWNrLCB0aGlzLl9hbHBoYSk7XG4gICAgfVxufSk7XG5cbk9ORUNPTE9SLmluc3RhbGxNZXRob2QoJ2NsZWFyZXInLCBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuYWxwaGEoaXNOYU4oYW1vdW50KSA/IC0wLjEgOiAtYW1vdW50LCB0cnVlKTtcbn0pO1xuXG5cbk9ORUNPTE9SLmluc3RhbGxNZXRob2QoJ2RhcmtlbicsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5saWdodG5lc3MoaXNOYU4oYW1vdW50KSA/IC0wLjEgOiAtYW1vdW50LCB0cnVlKTtcbn0pO1xuXG5cbk9ORUNPTE9SLmluc3RhbGxNZXRob2QoJ2Rlc2F0dXJhdGUnLCBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2F0dXJhdGlvbihpc05hTihhbW91bnQpID8gLTAuMSA6IC1hbW91bnQsIHRydWUpO1xufSk7XG5cbmZ1bmN0aW9uIGdzICgpIHtcbiAgICB2YXIgcmdiID0gdGhpcy5yZ2IoKSxcbiAgICAgICAgdmFsID0gcmdiLl9yZWQgKiAwLjMgKyByZ2IuX2dyZWVuICogMC41OSArIHJnYi5fYmx1ZSAqIDAuMTE7XG5cbiAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlJHQih2YWwsIHZhbCwgdmFsLCB0aGlzLl9hbHBoYSk7XG59O1xuXG5PTkVDT0xPUi5pbnN0YWxsTWV0aG9kKCdncmV5c2NhbGUnLCBncyk7XG5PTkVDT0xPUi5pbnN0YWxsTWV0aG9kKCdncmF5c2NhbGUnLCBncyk7XG5cblxuT05FQ09MT1IuaW5zdGFsbE1ldGhvZCgnbGlnaHRlbicsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5saWdodG5lc3MoaXNOYU4oYW1vdW50KSA/IDAuMSA6IGFtb3VudCwgdHJ1ZSk7XG59KTtcblxuT05FQ09MT1IuaW5zdGFsbE1ldGhvZCgnbWl4JywgZnVuY3Rpb24gKG90aGVyQ29sb3IsIHdlaWdodCkge1xuICAgIG90aGVyQ29sb3IgPSBPTkVDT0xPUihvdGhlckNvbG9yKS5yZ2IoKTtcbiAgICB3ZWlnaHQgPSAxIC0gKGlzTmFOKHdlaWdodCkgPyAwLjUgOiB3ZWlnaHQpO1xuXG4gICAgdmFyIHcgPSB3ZWlnaHQgKiAyIC0gMSxcbiAgICAgICAgYSA9IHRoaXMuX2FscGhhIC0gb3RoZXJDb2xvci5fYWxwaGEsXG4gICAgICAgIHdlaWdodDEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIsXG4gICAgICAgIHdlaWdodDIgPSAxIC0gd2VpZ2h0MSxcbiAgICAgICAgcmdiID0gdGhpcy5yZ2IoKTtcblxuICAgIHJldHVybiBuZXcgT05FQ09MT1IuUkdCKFxuICAgICAgICByZ2IuX3JlZCAqIHdlaWdodDEgKyBvdGhlckNvbG9yLl9yZWQgKiB3ZWlnaHQyLFxuICAgICAgICByZ2IuX2dyZWVuICogd2VpZ2h0MSArIG90aGVyQ29sb3IuX2dyZWVuICogd2VpZ2h0MixcbiAgICAgICAgcmdiLl9ibHVlICogd2VpZ2h0MSArIG90aGVyQ29sb3IuX2JsdWUgKiB3ZWlnaHQyLFxuICAgICAgICByZ2IuX2FscGhhICogd2VpZ2h0ICsgb3RoZXJDb2xvci5fYWxwaGEgKiAoMSAtIHdlaWdodClcbiAgICApO1xufSk7XG5cbk9ORUNPTE9SLmluc3RhbGxNZXRob2QoJ25lZ2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmdiID0gdGhpcy5yZ2IoKTtcbiAgICByZXR1cm4gbmV3IE9ORUNPTE9SLlJHQigxIC0gcmdiLl9yZWQsIDEgLSByZ2IuX2dyZWVuLCAxIC0gcmdiLl9ibHVlLCB0aGlzLl9hbHBoYSk7XG59KTtcblxuT05FQ09MT1IuaW5zdGFsbE1ldGhvZCgnb3BhcXVlcicsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYShpc05hTihhbW91bnQpID8gMC4xIDogYW1vdW50LCB0cnVlKTtcbn0pO1xuXG5PTkVDT0xPUi5pbnN0YWxsTWV0aG9kKCdyb3RhdGUnLCBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiB0aGlzLmh1ZSgoZGVncmVlcyB8fCAwKSAvIDM2MCwgdHJ1ZSk7XG59KTtcblxuXG5PTkVDT0xPUi5pbnN0YWxsTWV0aG9kKCdzYXR1cmF0ZScsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0aW9uKGlzTmFOKGFtb3VudCkgPyAwLjEgOiBhbW91bnQsIHRydWUpO1xufSk7XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vZ2ltcC5zb3VyY2VhcmNoaXZlLmNvbS9kb2N1bWVudGF0aW9uLzIuNi42LTF1YnVudHUxL2NvbG9yLXRvLWFscGhhXzhjLXNvdXJjZS5odG1sXG4vKlxuICAgIHRvQWxwaGEgcmV0dXJucyBhIGNvbG9yIHdoZXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGFyZ3VtZW50IGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gYWxwaGFcbiovXG5PTkVDT0xPUi5pbnN0YWxsTWV0aG9kKCd0b0FscGhhJywgZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIG1lID0gdGhpcy5yZ2IoKSxcbiAgICAgICAgb3RoZXIgPSBPTkVDT0xPUihjb2xvcikucmdiKCksXG4gICAgICAgIGVwc2lsb24gPSAxZS0xMCxcbiAgICAgICAgYSA9IG5ldyBPTkVDT0xPUi5SR0IoMCwgMCwgMCwgbWUuX2FscGhhKSxcbiAgICAgICAgY2hhbm5lbHMgPSBbJ19yZWQnLCAnX2dyZWVuJywgJ19ibHVlJ107XG5cbiAgICBjaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIGlmIChtZVtjaGFubmVsXSA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIGFbY2hhbm5lbF0gPSBtZVtjaGFubmVsXTtcbiAgICAgICAgfSBlbHNlIGlmIChtZVtjaGFubmVsXSA+IG90aGVyW2NoYW5uZWxdKSB7XG4gICAgICAgICAgICBhW2NoYW5uZWxdID0gKG1lW2NoYW5uZWxdIC0gb3RoZXJbY2hhbm5lbF0pIC8gKDEgLSBvdGhlcltjaGFubmVsXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVbY2hhbm5lbF0gPiBvdGhlcltjaGFubmVsXSkge1xuICAgICAgICAgICAgYVtjaGFubmVsXSA9IChvdGhlcltjaGFubmVsXSAtIG1lW2NoYW5uZWxdKSAvIG90aGVyW2NoYW5uZWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYVtjaGFubmVsXSA9IDA7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhLl9yZWQgPiBhLl9ncmVlbikge1xuICAgICAgICBpZiAoYS5fcmVkID4gYS5fYmx1ZSkge1xuICAgICAgICAgICAgbWUuX2FscGhhID0gYS5fcmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWUuX2FscGhhID0gYS5fYmx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYS5fZ3JlZW4gPiBhLl9ibHVlKSB7XG4gICAgICAgIG1lLl9hbHBoYSA9IGEuX2dyZWVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1lLl9hbHBoYSA9IGEuX2JsdWU7XG4gICAgfVxuXG4gICAgaWYgKG1lLl9hbHBoYSA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIG1lO1xuICAgIH1cblxuICAgIGNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgbWVbY2hhbm5lbF0gPSAobWVbY2hhbm5lbF0gLSBvdGhlcltjaGFubmVsXSkgLyBtZS5fYWxwaGEgKyBvdGhlcltjaGFubmVsXTtcbiAgICB9KTtcbiAgICBtZS5fYWxwaGEgKj0gYS5fYWxwaGE7XG5cbiAgICByZXR1cm4gbWU7XG59KTtcblxuLypnbG9iYWwgb25lKi9cblxuLy8gVGhpcyBmaWxlIGlzIHB1cmVseSBmb3IgdGhlIGJ1aWxkIHN5c3RlbVxuXG4vLyBPcmRlciBpcyBpbXBvcnRhbnQgdG8gcHJldmVudCBjaGFubmVsIG5hbWUgY2xhc2hlcy4gTGFiIDwtPiBoc0xcblxuLy8gQ29udmVuaWVuY2UgZnVuY3Rpb25zXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/onecolor/one-color-all-debug.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ })

}]);